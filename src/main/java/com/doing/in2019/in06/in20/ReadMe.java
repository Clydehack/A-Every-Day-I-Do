package com.doing.in2019.in06.in20;

public class ReadMe {

	/**
	 * Enterprise Architect（EA） -- UML软件开发与建模工具
	 * 
	 * 		工作流程：
	 * 			1.需求提出 -- 客户、销售、运维、老板、其他渠道等等
	 * 			2.产品原型 -- 产品画出
	 * 			3.需求确认 -- 其他成员评审：	1.需求是否可行	2.确认待完成需求	等等
	 * 			4.用例设计 -- 研发经理画出用例
	 * 			5.概要设计 -- 就是用EA，根据用例设计，画活动图（其实叫流程图也没毛病）：通过泳道，完成用户层（可以理解为controller层）→ service层的内部逻辑（方法的大概逻辑）,一个活动图对应一个接口
	 * 			6.概要评审 -- 分析概要是否可行
	 * 			7.ER设计	-- 根据需求设计数据库表
	 * 			8.提供接口 -- 根据概要设计，通过swagger提供接口给前端
	 * 			9.开发 -- 前后端同时实现功能
	 * 			10.测试 -- 单独的测试人员进行测试
	 * 			11.完成
	 * 
	 * 
	 * 分布式锁：
	 * 
	 * 		一般有三种实现方式：
	 * 			1.数据库乐观锁 - 相当于数据库原生方案
	 * 			2.基于Redis - 单线程结构，如果redis是多机部署的，可以尝试使用redisson实现，redis官方提供的Java组件
	 * 			3.基于ZooKeeper - 有视频 TODO 找时间研究一下
	 * 
	 * 		保证分布式锁可用的四个条件：
	 * 			1.互斥性 - 任意时刻，只有一个客户端持有锁
	 * 			2.不死锁 - 即使一个客户端持有锁，并且崩溃时未能主动解锁，也能保证后续其他客户端能加锁
	 * 			3.容错性 - 只要大部分节点正常运行，客户端就能加锁和解锁
	 * 			4.同一客户端 - 加锁和解锁必须时同一个客户端，客户端不能把别人加的锁解了。
	 * 
	 * 		
	 * 
	 */
}