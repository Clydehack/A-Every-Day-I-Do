package com.doing.in2019.in05.in22.Netty;

public class ReadMe {

	/**
	 *  Netty 是一个提供了易于使用的API的客户端/服务端框架
	 *  	并发高 - NIO
	 *  	传输快 - 零拷贝
	 *  	事件驱动
	 *  	简化了TCP和UDP编程
	 *  	提供了http、websocket、ssl、大文件传输等协议支持
	 *  	Dubbo使用了Netty
	 *  
	 *  
	 *  Netty提供了3种（Reactor）线程模型
	 *  	小型应用场景 - 单线程模型（理论上是AIO模型）：
	 *  		所有的io操作都是由同一个NIO线程处理的，当数据量太大，就会把这一个线程压垮
	 *  		作为服务端，它用于接收客户端所有的连接
	 *  		作为客户端，它就会向服务端发起所有的连接
	 *  		可以理解为request和response，发送、读取、响应消息
	 * 
	 *  	小型应用场景 - 多线程模型：
	 *  		一个NIO线程接受请求，一组NIO线程（或者是一个线程池）处理
	 *  		在单线程的基础上加了Reactor线程池
	 *  		不到百万级别就得挂了
	 *  
	 * （官方推荐模型）百万并发场景 - 主从线程模型：
	 *  		一组（主）线程池接受请求，一组（从）线程池处理
	 *  		比如：主线程池进行客户端登陆、握手、安全认证等等，从线程进行编解码等等
	 *  		
	 *  Hello Netty  (netty - 开发流程)
	 *  	1.构建一对主从线程组
	 *  	2.定义服务器启动类
	 *  	3.为服务器设置Channel
	 *  	4.设置处理从线程池的助手类初始化器（写数据、读数据、编解码处理）
	 *  	5.监听启动和关闭服务器
	 */
	
	/**
	 * 	（AIO、BIO、NIO概念）
	 *  	阻塞/非阻塞	(线程访问资源，资源是否准备就绪)
	 *  		阻塞：等待资源准备就绪
	 *  		非阻：如果请求的资源在处理中，就请求下一个资源
	 * 
	 *  	同步/异步		(访问数据的一种机制)
	 *  		同步：主动请求，等待io操作完成后，返回响应
	 *  		异步：主动请求，不等待io操作，等待io操作完再回调
	 *  
	 *  	BIO
	 *  		同步阻塞io（简单，传统，并发低，性能低，依赖网速和带宽，jdk1.4以前的模式）
	 *  		生活实例：去上厕所，坑全满，A一直等着，A主动观察哪个坑好了，只要有坑好了，A就去占坑
	 *  		客户端和服务端一问一答模式，当客户端过多时，频繁创建销毁线程，浪费资源，并发高时就崩溃
	 *  		优化：	伪异步io，通过线程池来减少线程创建销毁，节省资源
	 *  		模型：	发起请求 → 一直阻塞 → 处理完成
	 *  
	 *  		一个服务器，n个客户端，每一个客户端建立起一个连接线程，每断开一个连接释放一次连接线程
	 *  
	 *  		优化后：建立一个连接线程池，减少连接线程的创建和释放消耗的资源
	 * 
	 * 
	 * 
	 *  	NIO
	 *  		同步非阻塞io（jdk1.4以后的模式）
	 *  		生活实例：去上厕所，坑全满，A去做别的，A时不时的主动观察哪个坑好了，只要有坑好了，A就去占坑
	 *  		通过用Channel注册到Selector实现；
	 *  		Selector是单线程，一个线程对应N个客户端；
	 *  		Channel是读写器；一个Selector对多个Channel
	 * 
	 *  		问题：	类库复杂、需要具备多线程技能、断线重连、网络阻塞、内部有bug - 所以有了Netty
	 *  		模型：	发起请求 → Selector主动轮询Channel → 处理请求 → 处理完成
	 * 
	 * 
	 * 		AIO
	 * 			异步非阻塞io（可以说是NIO2.0的概念，使用场景？？？）
	 * 				生活实例：去上厕所，坑全满，A去做别的，坑好了要有B主动通知A，A去占坑
	 * 				A调用B，不等待；B处理完回调A通知A
	 * 				模型：	发起请求 →  →  → 通知回调
	 * 			异步阻塞io
	 * 				生活实例：去上厕所，坑全满，A一直等着，坑好了要有B主动通知A，A去占坑
	 * 				A阻塞，等待B处理，B处理完调用A回调方法通知A可以调用B了。（几乎不怎么用）
	 */
	
	/**
	 *  实时通讯：（3种方式）
	 *  
	 *  	Ajax轮询
	 *  		js通过浏览器，每隔10s-30s请求一次后端接口，查看是否有更新的数据，死循环！
	 *  		后台管理系统的首页，控制面板里的数据，就通过这种方法简单的完成。
	 *  		本质就是不停的建立http连接
	 *  
	 *  	Long pull
	 *  		阻塞模型，客户端发起请求后，服务器无响应，客户端就卡住不动，直到响应了才有反应。
	 *  		本质就是不停的建立http连接
	 *  
	 *  	webSocket
	 *  		一种基于http的协议，就像游戏，一次登录，一直都在线，直到退出登录
	 */
	
	/**
	 *  （零拷贝 及 Java流缓冲区 概念）
	 *  	
	 *  	
	 */
}